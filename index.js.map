{"version":3,"file":"index.js","sources":["type.model.ts","typeof.ts","empty.ts","filled.ts"],"sourcesContent":["import {Overwrite, PickByValue, SetComplement} from 'utility-types';\r\n\r\nexport enum Type {\r\n    array = 'array',\r\n    bigint = 'bigint',\r\n    boolean = 'boolean',\r\n    date = 'date',\r\n    error = 'error',\r\n    function = 'function',\r\n    nan = 'nan',\r\n    null = 'null',\r\n    number = 'number',\r\n    object = 'object',\r\n    promise = 'promise',\r\n    regexp = 'regexp',\r\n    string = 'string',\r\n    symbol = 'symbol',\r\n    'undefined' = 'undefined',\r\n    unset = 'unset',\r\n}\r\n\r\ntype AnyFn = (...args: any[]) => any;\r\n\r\nexport interface TypeMap {\r\n    array: any[]\r\n    bigint: bigint\r\n    boolean: boolean\r\n    date: Date\r\n    error: Error\r\n    function: AnyFn\r\n    nan: number\r\n    null: null\r\n    number: number\r\n    object: Object & { [I in string | number | symbol]?: any }\r\n    promise: Promise<any>\r\n    regexp: RegExp\r\n    string: string\r\n    symbol: symbol\r\n    undefined: undefined\r\n    unset: null | undefined\r\n}\r\n\r\nexport type ExtendedTypeName = keyof TypeMap;\r\nexport type ExtendedType<K extends ExtendedTypeName = ExtendedTypeName> = TypeMap[K];\r\n\r\nexport type EmptyRegExp = RegExp & {\r\n    readonly source: '(?:)'\r\n}\r\n\r\nexport interface EmptyTypeMap extends TypeMap {\r\n    array: []\r\n    bigint: never\r\n    boolean: never\r\n    date: never\r\n    error: Overwrite<Error, { message: '' }>\r\n    function: () => void\r\n    null: null\r\n    number: never\r\n    nan: number\r\n    object: Object & { [I in string | number | symbol]: never }\r\n    promise: never\r\n    regexp: EmptyRegExp\r\n    string: ''\r\n    symbol: never\r\n    undefined: undefined\r\n    unset: null | undefined\r\n}\r\n\r\nexport type NonNever<T extends {}> = Pick<T, { [K in keyof T]: T[K] extends never ? never : K }[keyof T]>;\r\nexport type Never<T extends {}> = Pick<T, { [K in keyof T]: T[K] extends never ? K : never }[keyof T]>;\r\n\r\nexport type PossibleEmptyMap = NonNever<EmptyTypeMap>;\r\nexport type PossibleEmptyInitialTypeMap = Pick<TypeMap, keyof PossibleEmptyMap>;\r\nexport type PossibleEmptyType = PossibleEmptyInitialTypeMap[keyof PossibleEmptyInitialTypeMap];\r\nexport type EmptyTypeNameByType<V extends ExtendedType> = keyof PickByValue<PossibleEmptyMap, V>;\r\n\r\n// export type PossibleEmptyTypeName = keyof PossibleEmptyInitialTypeMap;\r\n\r\nexport type ImpossibleEmptyMap = Never<EmptyTypeMap>;\r\nexport type ImpossibleEmptyInitialTypeMap = Pick<TypeMap, keyof ImpossibleEmptyMap>;\r\nexport type ImpossibleEmptyType = ImpossibleEmptyInitialTypeMap[keyof ImpossibleEmptyInitialTypeMap];\r\nexport type FilledByDefaultTypeNameByType<V extends ImpossibleEmptyType> = keyof PickByValue<ImpossibleEmptyMap, V>;\r\n// export type ImpossibleToBeEmptyTypeName = keyof ImpossibleToBeEmptyInitialTypeMap;\r\n\r\nexport type FilledTypeMap = Overwrite<TypeMap, {\r\n    nan: never\r\n    null: never\r\n    undefined: never\r\n    unset: never\r\n}>\r\n\r\nexport type TypeNameByType<V extends ExtendedType> = keyof PickByValue<TypeMap, V>;\r\nexport type EmptyTypeByType<V extends ExtendedType> = EmptyTypeMap[TypeNameByType<V>];","import {TypeMap, Type} from './type.model';\r\n\r\nexport const typeOf = <N extends keyof TypeMap, T extends TypeMap[N]>(obj: T): N => {\r\n    if (obj === null || obj === undefined) {\r\n        return String(obj) as N;\r\n    }\r\n\r\n    const type = typeof obj;\r\n\r\n    if (type === 'object') {\r\n        return Object.prototype.toString.call(obj)\r\n            .replace(/\\[object (.*)]/, '$1')\r\n            .toLowerCase();\r\n    }\r\n\r\n    if (type === 'number' && Number.isNaN(obj as number)) {\r\n        return 'nan' as N;\r\n    }\r\n\r\n    return type as N;\r\n};\r\n\r\n\r\n\r\nexport const isTypeOf = <N extends keyof TypeMap | Type>(\r\n    obj: TypeMap[keyof TypeMap],\r\n    type: N,\r\n    ...otherTypes: N[]\r\n): obj is TypeMap[N] => {\r\n    const checkedType: Type = typeOf(obj);\r\n    const typesToCheck: N[] = [type, ...otherTypes];\r\n\r\n    return typesToCheck.reduce((acc, type) => {\r\n        if (acc) {\r\n            return acc;\r\n        }\r\n\r\n        if (type === Type.unset && [Type.nan, Type.null, Type['undefined']].includes(checkedType)) {\r\n            return true;\r\n        }\r\n\r\n        return checkedType === type;\r\n    }, false);\r\n};","import {typeOf} from './typeof';\r\nimport {\r\n    EmptyTypeMap,\r\n    Type,\r\n    TypeMap,\r\n} from './type.model';\r\n\r\nexport function isEmpty<N extends keyof EmptyTypeMap | Type>(\r\n    obj: TypeMap[keyof TypeMap],\r\n    type: N,\r\n    ...otherTypes: N[]\r\n): obj is (TypeMap & EmptyTypeMap)[N] {\r\n    const typesToCheck: N[] = [type, ...otherTypes];\r\n    const typeOfObj = typeOf(obj);\r\n\r\n    if (!typesToCheck.includes(typeOfObj as N)) {\r\n        return false;\r\n    }\r\n\r\n    if (typeOfObj) {\r\n        return isEmptyCheck(obj, typeOfObj);\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nconst isObjectEmpty = (obj: TypeMap[Type.object]) => {\r\n    for (const key in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nconst isFunctionEmpty = (obj: TypeMap[Type.function]) => {\r\n    const nonArrowString = obj.toString().replace(/(\\s|\\n|=>)/g, '');\r\n\r\n    return /^(function)?([a-zA-Z_$][0-9a-zA-Z_$]*)?\\(\\){}$/.test(nonArrowString);\r\n};\r\n\r\nexport const isEmptyCheck = <N extends keyof TypeMap>(obj: any, type?: N): obj is EmptyTypeMap[N] => {\r\n    switch (type) {\r\n        case Type.array: return obj.length === 0;\r\n        case Type.object: return isObjectEmpty(obj);\r\n        case Type.string: return obj === '';\r\n        case Type.regexp: return obj.toString() === new RegExp('').toString();\r\n        case Type.function: return isFunctionEmpty(obj);\r\n        case Type.error: return obj.message === '';\r\n        case Type['undefined']:\r\n        case Type.null:\r\n            return true;\r\n    }\r\n\r\n    return false;\r\n};","import {\r\n    EmptyTypeMap,\r\n    ExtendedType,\r\n    ExtendedTypeName, FilledTypeMap, Type, TypeMap,\r\n} from './type.model';\r\nimport {isTypeOf, typeOf} from './typeof';\r\nimport {isEmptyCheck} from './empty';\r\n\r\nexport function isFilled<N extends keyof FilledTypeMap | Type>(\r\n    obj: TypeMap[keyof TypeMap],\r\n    ...type: N[]\r\n): obj is (TypeMap & FilledTypeMap)[N] {\r\n    const typeOfObj = typeOf(obj);\r\n\r\n    if (!type.includes(typeOfObj as N)) {\r\n        return false;\r\n    }\r\n\r\n    if (typeOfObj) {\r\n        return !isEmptyCheck(obj, typeOfObj);\r\n    }\r\n\r\n    return false;\r\n}"],"names":["Type","typeOf","obj","String","type","Object","prototype","toString","call","replace","toLowerCase","Number","isNaN","isEmptyCheck","array","length","object","const","key","hasOwnProperty","isObjectEmpty","string","regexp","RegExp","function","nonArrowString","test","isFunctionEmpty","error","message","null","checkedType","otherTypes","reduce","acc","unset","nan","includes","typesToCheck","typeOfObj"],"mappings":"AAEA,IAAYA,GAAAA,EAAAA,eAAAA,gCAERA,kBACAA,oBACAA,cACAA,gBACAA,sBACAA,YACAA,cACAA,kBACAA,kBACAA,oBACAA,kBACAA,kBACAA,kBACAA,sBACAA,oBChBSC,WAAyDC,MAC9DA,MAAAA,SACOC,OAAOD,OAGZE,SAAcF,QAEP,WAATE,EACOC,OAAOC,UAAUC,SAASC,KAAKN,GACjCO,QAAQ,iBAAkB,MAC1BC,cAGI,WAATN,GAAqBO,OAAOC,MAAMV,GAC3B,MAGJE,GCuBES,WAAyCX,EAAUE,UACpDA,QACCJ,aAAKc,aAA6B,IAAfZ,EAAIa,YACvBf,aAAKgB,uBAnBKd,OACde,IAAMC,KAAOhB,KACVG,OAAOC,UAAUa,eAAeX,KAAKN,EAAKgB,UACnC,SAIR,EAYsBE,CAAclB,QAClCF,aAAKqB,aAAuB,KAARnB,OACpBF,aAAKsB,cAAepB,EAAIK,aAAe,IAAIgB,OAAO,IAAIhB,gBACtDP,aAAKwB,yBAZOtB,OACfuB,EAAiBvB,EAAIK,WAAWE,QAAQ,cAAe,UAEtD,iDAAiDiB,KAAKD,GAS9BE,CAAgBzB,QACtCF,aAAK4B,YAA8B,KAAhB1B,EAAI2B,aACvB7B,kBAAK,QACLA,aAAK8B,YACC,SAGR,8CD9BP5B,EACAE,qEAGM2B,EAAoB9B,EAAOC,SACP,CAACE,UAAS4B,GAEhBC,gBAAQC,EAAK9B,UACzB8B,KAIA9B,IAASJ,aAAKmC,QAAS,CAACnC,aAAKoC,IAAKpC,aAAK8B,KAAM9B,kBAAK,IAAcqC,SAASN,KAItEA,IAAgB3B,IACxB,6BClCHF,EACAE,qEAGMkC,EAAoB,CAAClC,UAAS4B,GAC9BO,EAAYtC,EAAOC,WAEpBoC,EAAaD,SAASE,MAIvBA,GACO1B,EAAaX,EAAKqC,8BCX7BrC,qEAGMqC,EAAYtC,EAAOC,WAEpBE,EAAKiC,SAASE,MAIfA,IACQ1B,EAAaX,EAAKqC"}