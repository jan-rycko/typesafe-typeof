{"version":3,"file":"index.mjs","sources":["type.model.ts","typeof.ts","empty.ts","filled.ts"],"sourcesContent":["import {Overwrite, PickByValue, SetDifference, SetComplement} from 'utility-types';\r\n\r\nexport enum Type {\r\n    boolean = 'boolean',\r\n    number = 'number',\r\n    string = 'string',\r\n    function = 'function',\r\n    array = 'array',\r\n    date = 'date',\r\n    regexp = 'regexp',\r\n    object = 'object',\r\n    bigint = 'bigint',\r\n    symbol = 'symbol',\r\n    null = 'null',\r\n    undefined = 'undefined',\r\n}\r\n\r\ntype AnyFn = (...args: any[]) => any;\r\n\r\nexport interface StringToTypeMap {\r\n    boolean: boolean\r\n    number: number\r\n    string: string\r\n    function: Function & AnyFn\r\n    array: Array<any> & any[]\r\n    date: Date\r\n    regexp: RegExp\r\n    object: Object & { [I in string | number]?: any }\r\n    bigint: bigint\r\n    symbol: symbol\r\n    null: null\r\n    undefined: undefined\r\n}\r\n\r\nexport type ExtendedTypeName = keyof StringToTypeMap;\r\nexport type ExtendedType<K extends ExtendedTypeName = ExtendedTypeName> = StringToTypeMap[K];\r\n\r\nexport type EmptyRegExp = RegExp & {\r\n    readonly source: '(?:)'\r\n}\r\n\r\nexport interface StringToEmptyTypeMap extends StringToTypeMap {\r\n    boolean: never\r\n    number: never\r\n    string: ''\r\n    function: () => undefined\r\n    array: []\r\n    date: never\r\n    regexp: EmptyRegExp\r\n    object: { [I in string | number]: never }\r\n    bigint: never\r\n    symbol: never\r\n    null: null\r\n    undefined: undefined\r\n}\r\n\r\nexport type NonNever<T extends {}> = Pick<T, { [K in keyof T]: T[K] extends never ? never : K }[keyof T]>;\r\nexport type Never<T extends {}> = Pick<T, { [K in keyof T]: T[K] extends never ? K : never }[keyof T]>;\r\n\r\nexport type PossibleEmptyMap = NonNever<StringToEmptyTypeMap>;\r\nexport type PossibleEmptyInitialTypeMap = Pick<StringToTypeMap, keyof PossibleEmptyMap>;\r\nexport type PossibleEmptyType = PossibleEmptyInitialTypeMap[keyof PossibleEmptyInitialTypeMap];\r\nexport type EmptyTypeNameByType<V extends ExtendedType> = keyof PickByValue<PossibleEmptyMap, V>;\r\n\r\n// export type PossibleEmptyTypeName = keyof PossibleEmptyInitialTypeMap;\r\n\r\nexport type ImpossibleEmptyMap = Never<StringToEmptyTypeMap>;\r\nexport type ImpossibleEmptyInitialTypeMap = Pick<StringToTypeMap, keyof ImpossibleEmptyMap>;\r\nexport type ImpossibleEmptyType = ImpossibleEmptyInitialTypeMap[keyof ImpossibleEmptyInitialTypeMap];\r\nexport type FilledByDefaultTypeNameByType<V extends ImpossibleEmptyType> = keyof PickByValue<ImpossibleEmptyMap, V>;\r\n// export type ImpossibleToBeEmptyTypeName = keyof ImpossibleToBeEmptyInitialTypeMap;\r\n\r\nexport type StringToFilledTypeMap = Overwrite<StringToTypeMap, {\r\n    string: SetComplement<string, ''>\r\n    null: never\r\n    undefined: never\r\n}>\r\n\r\nexport type TypeNameByType<V extends ExtendedType> = keyof PickByValue<StringToTypeMap, V>;\r\nexport type EmptyTypeByType<V extends ExtendedType> = StringToEmptyTypeMap[TypeNameByType<V>];","import { typeOf as nonTypedTypeof } from 'remedial';\r\nimport {PickByValueExact} from 'utility-types';\r\nimport { ExtendedType, ExtendedTypeName, StringToTypeMap, Type } from './type.model';\r\n\r\nexport const typeOf = <T extends ExtendedType, N extends keyof PickByValueExact<StringToTypeMap, T>>(obj: T): N => {\r\n    const type = nonTypedTypeof(obj); // supports array, date, regexp and null type but defaults to object for some reason\r\n\r\n    return type === 'object' ?\r\n        typeof obj // fix for bigint, symbol and any future type defaulting to object by remedial\r\n        : type;\r\n};\r\n\r\nexport const isTypeOf = <K extends ExtendedTypeName | Type>(obj: any, type: K): obj is StringToTypeMap[K] => {\r\n    return typeOf(obj) === type;\r\n};","import {isTypeOf, typeOf} from './typeof';\r\nimport {\r\n    ExtendedTypeName,\r\n    StringToEmptyTypeMap,\r\n    Type,\r\n    StringToTypeMap,\r\n    ExtendedType,\r\n    TypeNameByType,\r\n    StringToFilledTypeMap,\r\n    PossibleEmptyMap,\r\n    PossibleEmptyType,\r\n    ImpossibleEmptyType, EmptyTypeNameByType, FilledByDefaultTypeNameByType,\r\n} from './type.model';\r\n\r\n// export function isEmpty<T extends ImpossibleEmptyType, N extends FilledByDefaultTypeNameByType<T> = FilledByDefaultTypeNameByType<T>>(obj: T, type?: N): never;\r\n// export function isEmpty<T extends PossibleEmptyType>(obj: T): boolean;\r\n// export function isEmpty<T extends PossibleEmptyType, N extends EmptyTypeNameByType<T> = EmptyTypeNameByType<T>>(obj: T, type?: N): obj is PossibleEmptyMap[N];\r\n// export function isEmpty<T extends PossibleEmptyType | ImpossibleEmptyType, N extends TypeNameByType<T> = TypeNameByType<T>>(obj: T, type?: N): obj is PossibleEmptyMap[N] {\r\nexport const isEmpty = <T extends ExtendedType, N extends TypeNameByType<T> = TypeNameByType<T>>(obj: ExtendedType, type?: N): obj is StringToEmptyTypeMap[N] => {\r\n    if (type && !isTypeOf(obj, type)) {\r\n        return false;\r\n    }\r\n\r\n    const typeToCheck: N = type || typeOf(obj);\r\n\r\n    if (typeToCheck) {\r\n        return isEmptyCheck(obj, typeToCheck);\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\nconst isObjectEmpty = (obj: StringToTypeMap[Type.object]) => {\r\n    for (const key in obj) {\r\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nconst isFunctionEmpty = (obj: StringToTypeMap[Type.function]) => {\r\n    const nonArrowString = obj.toString().replace(/(\\s|\\n|=>)/g, '');\r\n\r\n    return /^(function)?([a-zA-Z_$][0-9a-zA-Z_$]*)?\\(\\){}$/.test(nonArrowString);\r\n};\r\n\r\nexport const isEmptyCheck = <K extends ExtendedTypeName | Type>(obj: any, type?: K): obj is StringToEmptyTypeMap[K] => {\r\n    switch (type) {\r\n        case Type.array: return obj.length === 0;\r\n        case Type.object: return isObjectEmpty(obj);\r\n        case Type.string: return obj === '';\r\n        case Type.regexp: return obj.toString() === new RegExp('').toString();\r\n        case Type.function: return isFunctionEmpty(obj);\r\n        case Type.undefined:\r\n        case Type.null:\r\n            return true;\r\n    }\r\n\r\n    return false;\r\n};","import {\r\n    ExtendedType,\r\n    ExtendedTypeName,\r\n} from './type.model';\r\nimport {isTypeOf, typeOf} from './typeof';\r\nimport {isEmptyCheck} from './empty';\r\n\r\nexport function isFilled<T extends ExtendedType, N extends ExtendedTypeName = ExtendedTypeName>(obj: ExtendedType, type: N): boolean {\r\n    if (type && !isTypeOf(obj, type)) {\r\n        return false;\r\n    }\r\n\r\n    const typeToCheck: N = type || typeOf(obj);\r\n\r\n    if (typeToCheck) {\r\n        return !isEmptyCheck(obj, typeToCheck);\r\n    }\r\n\r\n    return false;\r\n}"],"names":["Type","typeOf","obj","type","nonTypedTypeof","isTypeOf","isEmpty","typeToCheck","isEmptyCheck","array","length","object","const","key","Object","prototype","hasOwnProperty","call","isObjectEmpty","string","regexp","toString","RegExp","function","nonArrowString","replace","test","isFunctionEmpty","undefined","null","isFilled"],"mappings":"sCAEYA,GAAZ,SAAYA,GACRA,oBACAA,kBACAA,kBACAA,sBACAA,gBACAA,cACAA,kBACAA,kBACAA,kBACAA,kBACAA,cACAA,sBAZJ,CAAYA,IAAAA,WCECC,WAAwFC,OAC3FC,EAAOC,EAAeF,SAEZ,WAATC,SACID,EACLC,GAGGE,WAA+CH,EAAUC,UAC3DF,EAAOC,KAASC,GCKdG,WAAoFJ,EAAmBC,MAC5GA,IAASE,EAASH,EAAKC,UAChB,MAGLI,EAAiBJ,GAAQF,EAAOC,WAElCK,GACOC,EAAaN,EAAKK,IAsBpBC,WAAmDN,EAAUC,UAC9DA,QACCH,EAAKS,aAA6B,IAAfP,EAAIQ,YACvBV,EAAKW,uBAnBKT,OACdU,IAAMC,KAAOX,KACVY,OAAOC,UAAUC,eAAeC,KAAKf,EAAKW,UACnC,SAIR,EAYsBK,CAAchB,QAClCF,EAAKmB,aAAuB,KAARjB,OACpBF,EAAKoB,cAAelB,EAAImB,aAAe,IAAIC,OAAO,IAAID,gBACtDrB,EAAKuB,yBAZOrB,OACfsB,EAAiBtB,EAAImB,WAAWI,QAAQ,cAAe,UAEtD,iDAAiDC,KAAKF,GAS9BG,CAAgBzB,QACtCF,EAAK4B,eACL5B,EAAK6B,YACC,SAGR,YCrDKC,EAAgF5B,EAAmBC,MAC3GA,IAASE,EAASH,EAAKC,UAChB,MAGLI,EAAiBJ,GAAQF,EAAOC,WAElCK,IACQC,EAAaN,EAAKK"}